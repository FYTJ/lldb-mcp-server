# Example: Find a Security Vulnerability

This example demonstrates how to identify a buffer overflow vulnerability using the LLDB MCP Server.

## Scenario

We have a program that exhibits undefined behavior. We suspect a memory corruption issue.

## Step-by-Step Analysis

### 1. Initialize and Load Target

```
Tool: lldb_initialize
Arguments: {}
â†’ sessionId: "vuln-session-001"

Tool: lldb_createTarget
Arguments: {
  "sessionId": "vuln-session-001",
  "file": "/path/to/examples/client/c_test/buffer_overflow/buffer_overflow"
}
```

### 2. Set Breakpoint at Suspicious Location

```
Tool: lldb_setBreakpoint
Arguments: {
  "sessionId": "vuln-session-001",
  "symbol": "main"
}

Response:
{
  "breakpoint": {
    "id": 1,
    "locations": [
      {
        "address": "0x100003f00",
        "file": "buffer_overflow.c",
        "line": 8
      }
    ]
  }
}
```

### 3. Launch and Hit Breakpoint

```
Tool: lldb_launch
Arguments: {
  "sessionId": "vuln-session-001",
  "args": []
}
```

### 4. Examine Buffer Before strcpy

```
Tool: lldb_evaluate
Arguments: {
  "sessionId": "vuln-session-001",
  "expression": "sizeof(buffer)"
}

Response:
{
  "result": {
    "value": "16",
    "type": "unsigned long"
  }
}

Tool: lldb_evaluate
Arguments: {
  "sessionId": "vuln-session-001",
  "expression": "strlen(input)"
}

Response:
{
  "result": {
    "value": "44",
    "type": "unsigned long"
  }
}
```

**Finding**: Buffer is 16 bytes, but input is 44 bytes!

### 5. Set Watchpoint on Buffer

```
Tool: lldb_evaluate
Arguments: {
  "sessionId": "vuln-session-001",
  "expression": "&buffer"
}

Response:
{
  "result": {
    "value": "0x7ffeefbff480",
    "type": "char (*)[16]"
  }
}

Tool: lldb_setWatchpoint
Arguments: {
  "sessionId": "vuln-session-001",
  "address": "0x7ffeefbff490",
  "size": 8,
  "read": false,
  "write": true
}
```

Note: Watchpoint set at buffer+16 to detect overflow

### 6. Step Over strcpy

```
Tool: lldb_stepOver
Arguments: {
  "sessionId": "vuln-session-001"
}
```

### 7. Check for Overflow

```
Tool: lldb_pollEvents
Arguments: {
  "sessionId": "vuln-session-001",
  "limit": 10
}

Response:
{
  "events": [
    {
      "type": "watchpointHit",
      "watchpointId": 1,
      "address": "0x7ffeefbff490"
    }
  ]
}
```

**Watchpoint triggered!** Memory beyond buffer was written.

### 8. Read Overflowed Memory

```
Tool: lldb_readMemory
Arguments: {
  "sessionId": "vuln-session-001",
  "address": "0x7ffeefbff480",
  "size": 64
}

Response:
{
  "address": "0x7ffeefbff480",
  "size": 64,
  "bytes": "54686973...",
  "ascii": "This string is way too long for the buffer!......."
}
```

### 9. Search for Dangerous Functions

```
Tool: lldb_getSuspiciousFunctions
Arguments: {
  "sessionId": "vuln-session-001"
}

Response:
{
  "suspiciousCalls": [
    {
      "function": "strcpy",
      "location": "buffer_overflow.c:17",
      "risk": "high",
      "reason": "No bounds checking, can cause buffer overflow"
    }
  ],
  "recommendations": [
    "Replace strcpy with strncpy or strlcpy",
    "Use bounds-checked string functions"
  ]
}
```

### 10. Terminate

```
Tool: lldb_terminate
Arguments: {
  "sessionId": "vuln-session-001"
}
```

## Vulnerability Report

### Summary
- **Type**: Stack Buffer Overflow
- **Location**: `buffer_overflow.c:17`
- **Function**: `strcpy(buffer, input)`
- **Severity**: High

### Details
- Buffer `buffer` is declared with size 16 bytes
- Input string `input` is 44 bytes long
- `strcpy` copies without bounds checking
- 28 bytes overflow beyond buffer boundary

### Exploitation Potential
- Stack corruption possible
- Return address overwrite potential
- Could lead to arbitrary code execution

### Remediation
```c
// Vulnerable code
strcpy(buffer, input);

// Fixed code - option 1: truncate
strncpy(buffer, input, sizeof(buffer) - 1);
buffer[sizeof(buffer) - 1] = '\0';

// Fixed code - option 2: check length first
if (strlen(input) < sizeof(buffer)) {
    strcpy(buffer, input);
} else {
    // Handle error
}
```

### CWE Classification
- CWE-120: Buffer Copy without Checking Size of Input
- CWE-787: Out-of-bounds Write
